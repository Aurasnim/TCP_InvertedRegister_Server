#include <stdio.h>
#include <string.h>
#include "lwip/err.h"
#include "lwip/tcp.h"
#include "xil_printf.h"

/* Структура для соединения */
typedef struct {
    struct tcp_pcb *pcb;
    char buffer[1024];
    int data_length;
} conn_data_t;

/* Глобальные переменные */
int connection_count = 0;
int data_received_flag = 0;
char last_received_data[256] = "";

/* Функция инверсии регистра */
void process_received_data(char *data, int length) {
    int i;

    /* Инверсия регистра */
    for (i = 0; i < length && data[i] != '\0'; i++) {
        if (data[i] >= 'a' && data[i] <= 'z') {
            data[i] = data[i] - 'a' + 'A';  // нижний -> ВЕРХНИЙ
        } else if (data[i] >= 'A' && data[i] <= 'Z') {
            data[i] = data[i] - 'A' + 'a';  // верхний -> нижний
        }
    }
}

/* Callback при получении данных */
err_t data_received_callback(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err) {
    conn_data_t *conn_data = (conn_data_t *)arg;

    if (!p) {
        /* Соединение закрыто */
        tcp_close(tpcb);
        tcp_recv(tpcb, NULL);
        if (conn_data) {
            mem_free(conn_data);
        }
        connection_count--;
        xil_printf("[СЕТЬ] Соединение закрыто. Активных: %d\r\n", connection_count);
        return ERR_OK;
    }

    /* Копируем данные */
    conn_data->data_length = p->len;
    if (conn_data->data_length > sizeof(conn_data->buffer) - 1) {
        conn_data->data_length = sizeof(conn_data->buffer) - 1;
    }

    memcpy(conn_data->buffer, p->payload, conn_data->data_length);
    conn_data->buffer[conn_data->data_length] = '\0';

    /* Сохраняем для консоли */
    data_received_flag = 1;
    strncpy(last_received_data, conn_data->buffer, sizeof(last_received_data)-1);
    last_received_data[sizeof(last_received_data)-1] = '\0';

    xil_printf("[СЕТЬ] Получено %d байт: %s\r\n", conn_data->data_length, conn_data->buffer);

    /* Обрабатываем данные - инверсия регистра */
    process_received_data(conn_data->buffer, conn_data->data_length);

    /* Создаем финальную строку с префиксом "PROCESSED: " */
    char final_buffer[1024];
    int final_length = snprintf(final_buffer, sizeof(final_buffer), "PROCESSED: %s", conn_data->buffer);

    if (final_length >= sizeof(final_buffer)) {
        final_length = sizeof(final_buffer) - 1;
        final_buffer[final_length] = '\0';
    }

    /* Проверяем место в буфере отправки */
    if (tcp_sndbuf(tpcb) < final_length) {
        xil_printf("[СЕТЬ] Мало места в буфере отправки: %d < %d\r\n", tcp_sndbuf(tpcb), final_length);
        pbuf_free(p);
        return ERR_MEM;
    }

    /* Отправляем обработанные данные с префиксом */
    err_t write_err = tcp_write(tpcb, final_buffer, final_length, TCP_WRITE_FLAG_COPY);
    if (write_err != ERR_OK) {
        xil_printf("[СЕТЬ] Ошибка отправки: %d\r\n", write_err);
        pbuf_free(p);
        return write_err;
    }

    /* Подтверждаем получение и освобождаем pbuf */
    tcp_recved(tpcb, p->len);
    pbuf_free(p);

    xil_printf("[СЕТЬ] Отправлено %d байт: %s\r\n", final_length, final_buffer);

    return ERR_OK;
}

/* Callback при новом соединении */
err_t connection_accepted_callback(void *arg, struct tcp_pcb *newpcb, err_t err) {
    conn_data_t *conn_data;

    if (err != ERR_OK || newpcb == NULL) {
        xil_printf("[СЕТЬ] Ошибка принятия соединения: %d\r\n", err);
        return ERR_VAL;
    }

    /* Выделяем память */
    conn_data = (conn_data_t *)mem_malloc(sizeof(conn_data_t));
    if (conn_data == NULL) {
        xil_printf("[СЕТЬ] Ошибка выделения памяти\r\n");
        return ERR_MEM;
    }

    memset(conn_data, 0, sizeof(conn_data_t));
    conn_data->pcb = newpcb;
    conn_data->data_length = 0;

    tcp_recv(newpcb, data_received_callback);
    tcp_arg(newpcb, conn_data);

    connection_count++;
    xil_printf("[СЕТЬ] Новое соединение. Активных: %d\r\n", connection_count);

    return ERR_OK;
}

/* Функция для консоли */
void get_network_stats(int *connections, int *data_flag, char *last_data) {
    *connections = connection_count;
    *data_flag = data_received_flag;
    if (data_received_flag) {
        strncpy(last_data, last_received_data, sizeof(last_received_data)-1);
        last_data[sizeof(last_received_data)-1] = '\0';
        data_received_flag = 0;
    } else {
        last_data[0] = '\0';
    }
}

/* Запуск TCP-сервера */
void start_custom_application(void) {
    struct tcp_pcb *pcb;
    err_t err;

    /* Создаем PCB */
    pcb = tcp_new();
    if (!pcb) {
        xil_printf("[СЕТЬ] Ошибка создания PCB\r\n");
        return;
    }

    /* Биндим на порт 12345 */
    err = tcp_bind(pcb, IP_ADDR_ANY, 12345);
    if (err != ERR_OK) {
        xil_printf("[СЕТЬ] Ошибка bind на порт 12345: %d\r\n", err);
        tcp_close(pcb);
        return;
    }

    /* Слушаем соединения */
    pcb = tcp_listen(pcb);
    if (!pcb) {
        xil_printf("[СЕТЬ] Ошибка listen\r\n");
        return;
    }

    /* Устанавливаем callback для принятия соединений */
    tcp_accept(pcb, connection_accepted_callback);

    xil_printf("[СЕТЬ] TCP-сервер запущен на порту 12345\r\n");
    xil_printf("[СЕТЬ] Готов к приему подключений\r\n");
}
