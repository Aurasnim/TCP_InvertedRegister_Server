#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "lwip/err.h"
#include "lwip/tcp.h"
#include "xil_printf.h"

/* Структура для соединения */
typedef struct {
    struct tcp_pcb *pcb;
    char buffer[1024];
} conn_data_t;

/* Глобальные переменные */
int connection_count = 0;
int data_received_flag = 0;
char last_received_data[256] = "";

/* Функция инверсии регистра с добавлением префикса */
void process_received_data(char *data, int length) {
    int i;

    /* Инверсия регистра для каждого символа */
    for (i = 0; i < length && data[i] != '\0'; i++) {
        if (islower(data[i])) {
            data[i] = toupper(data[i]);  // нижний -> ВЕРХНИЙ
        } else if (isupper(data[i])) {
            data[i] = tolower(data[i]);  // верхний -> нижний
        }
        // Цифры и другие символы остаются без изменений
    }

    /* Добавляем префикс к результату */
    char temp[1024];
    snprintf(temp, sizeof(temp), "MODIFIED: %s", data);
    strncpy(data, temp, sizeof(temp) - 1);
    data[sizeof(temp) - 1] = '\0';
}

/* Улучшенная функция инверсии регистра (альтернативная версия) */
void process_received_data_advanced(char *data, int length) {
    char temp[1024];
    int i;

    /* Создаем копию для модификации */
    strncpy(temp, data, sizeof(temp) - 1);
    temp[sizeof(temp) - 1] = '\0';

    /* Инверсия регистра */
    for (i = 0; temp[i] != '\0' && i < length; i++) {
        if (temp[i] >= 'a' && temp[i] <= 'z') {
            temp[i] = temp[i] - 'a' + 'A';  // в верхний регистр
        } else if (temp[i] >= 'A' && temp[i] <= 'Z') {
            temp[i] = temp[i] - 'A' + 'a';  // в нижний регистр
        }
    }

    /* Формируем итоговую строку */
    snprintf(data, length + 20, "PROCESSED: %s", temp);
}

/* Callback при получении данных */
err_t data_received_callback(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err) {
    conn_data_t *conn_data = (conn_data_t *)arg;

    if (!p) {
        /* Соединение закрыто */
        tcp_close(tpcb);
        tcp_recv(tpcb, NULL);
        if (conn_data) {
            mem_free(conn_data);
        }
        connection_count--;
        xil_printf("[СЕТЬ] Соединение закрыто. Активных: %d\r\n", connection_count);
        return ERR_OK;
    }

    /* Копируем данные */
    int data_len = p->len;
    if (data_len > sizeof(conn_data->buffer) - 1) {
        data_len = sizeof(conn_data->buffer) - 1;
    }

    memcpy(conn_data->buffer, p->payload, data_len);
    conn_data->buffer[data_len] = '\0';

    /* Сохраняем для консоли */
    data_received_flag = 1;
    strncpy(last_received_data, conn_data->buffer, sizeof(last_received_data)-1);

    xil_printf("[СЕТЬ] Получено: %s\r\n", conn_data->buffer);

    /* Обрабатываем данные - ИНВЕРСИЯ РЕГИСТРА */
    process_received_data_advanced(conn_data->buffer, data_len);

    /* Отправляем обратно */
    tcp_write(tpcb, conn_data->buffer, strlen(conn_data->buffer), 1);

    /* Подтверждаем получение */
    tcp_recved(tpcb, p->len);
    pbuf_free(p);

    return ERR_OK;
}

/* Callback при новом соединении */
err_t connection_accepted_callback(void *arg, struct tcp_pcb *newpcb, err_t err) {
    conn_data_t *conn_data;

    if (err != ERR_OK || newpcb == NULL) {
        return ERR_VAL;
    }

    /* Выделяем память */
    conn_data = (conn_data_t *)mem_malloc(sizeof(conn_data_t));
    if (conn_data == NULL) {
        xil_printf("Ошибка выделения памяти\r\n");
        return ERR_MEM;
    }

    memset(conn_data, 0, sizeof(conn_data_t));
    conn_data->pcb = newpcb;

    tcp_recv(newpcb, data_received_callback);
    tcp_arg(newpcb, conn_data);

    connection_count++;
    xil_printf("[СЕТЬ] Новое соединение. Активных: %d\r\n", connection_count);

    return ERR_OK;
}

/* Функция для консоли */
void get_network_stats(int *connections, int *data_flag, char *last_data) {
    *connections = connection_count;
    *data_flag = data_received_flag;
    if (data_received_flag) {
        strncpy(last_data, last_received_data, 255);
        data_received_flag = 0;
    } else {
        last_data[0] = '\0';
    }
}

/* Запуск TCP-сервера */
void start_custom_application(void) {
    struct tcp_pcb *pcb;
    err_t err;

    /* Создаем PCB */
    pcb = tcp_new_ip_type(IPADDR_TYPE_ANY);
    if (!pcb) {
        xil_printf("Ошибка создания PCB\r\n");
        return;
    }

    /* Биндим на порт 12345 */
    err = tcp_bind(pcb, IP_ANY_TYPE, 12345);
    if (err != ERR_OK) {
        xil_printf("Ошибка bind: %d\r\n", err);
        mem_free(pcb);
        return;
    }

    /* Слушаем */
    pcb = tcp_listen(pcb);
    if (!pcb) {
        xil_printf("Ошибка listen\r\n");
        return;
    }

    /* Устанавливаем callback */
    tcp_accept(pcb, connection_accepted_callback);

    xil_printf("[СЕТЬ] TCP-сервер запущен на порту 12345\r\n");
}
