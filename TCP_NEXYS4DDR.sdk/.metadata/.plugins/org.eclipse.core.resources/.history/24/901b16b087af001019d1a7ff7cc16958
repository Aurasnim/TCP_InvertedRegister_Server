#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "lwip/err.h"
#include "lwip/tcp.h"
#include "xil_printf.h"

/* Структура для соединения */
typedef struct {
    struct tcp_pcb *pcb;
    char buffer[1024];
    int data_length;
} conn_data_t;

/* Глобальные переменные */
int connection_count = 0;
int data_received_flag = 0;
char last_received_data[256] = "";

/* Функция инверсии регистра с поддержкой русского языка */
void process_received_data(char *data, int length) {
    int i;

    /* Инверсия регистра для английских и русских символов */
    for (i = 0; i < length && data[i] != '\0'; i++) {
        unsigned char c = data[i];

        // Английские буквы
        if (c >= 'a' && c <= 'z') {
            data[i] = c - 'a' + 'A';  // нижний -> ВЕРХНИЙ
        }
        else if (c >= 'A' && c <= 'Z') {
            data[i] = c - 'A' + 'a';  // верхний -> нижний
        }
        // Русские буквы (кириллица в UTF-8)
        else if (c == 0xD0) {
            // Это первый байт русской буквы в UTF-8
            if (i + 1 < length) {
                unsigned char next = data[i + 1];
                // Русские строчные буквы (а-я)
                if (next >= 0xB0 && next <= 0xBF) {
                    data[i + 1] = next - 0xB0 + 0x90;  // в заглавные
                }
                // Русские заглавные буквы (А-Я)
                else if (next >= 0x90 && next <= 0x9F && next != 0x97) {
                    // Ё пропускаем, так как у него особый случай
                    if (next != 0x81) { // Не трогаем Ё
                        data[i + 1] = next - 0x90 + 0xB0;  // в строчные
                    }
                }
            }
        }
        // Буква Ё/ё (особый случай)
        else if (c == 0xD1) {
            if (i + 1 < length) {
                unsigned char next = data[i + 1];
                // строчная ё
                if (next == 0x91) {
                    data[i + 1] = 0x81;  // в заглавную Ё
                }
                // заглавная Ё
                else if (next == 0x81) {
                    data[i + 1] = 0x91;  // в строчную ё
                }
            }
        }
    }
}

/* Улучшенная функция для лучшей поддержки русского */
void process_received_data_improved(char *data, int length) {
    int i = 0;

    while (i < length && data[i] != '\0') {
        // Обрабатываем UTF-8 символы
        if ((data[i] & 0x80) == 0) {
            // ASCII символ
            if (data[i] >= 'a' && data[i] <= 'z') {
                data[i] = data[i] - 'a' + 'A';
            }
            else if (data[i] >= 'A' && data[i] <= 'Z') {
                data[i] = data[i] - 'A' + 'a';
            }
            i++;
        }
        else if ((data[i] & 0xE0) == 0xC0) {
            // 2-байтовый UTF-8 символ (кириллица)
            if (i + 1 < length) {
                unsigned char byte1 = data[i];
                unsigned char byte2 = data[i + 1];

                // Русские буквы в диапазоне А-Я (U+0410 - U+042F)
                if (byte1 == 0xD0 && byte2 >= 0x90 && byte2 <= 0xAF) {
                    // Заглавные -> строчные
                    if (byte2 <= 0x9F) {
                        data[i + 1] = byte2 + 0x20;
                    }
                }
                // Русские буквы в диапазоне а-я (U+0430 - U+044F)
                else if (byte1 == 0xD1 && byte2 >= 0x80 && byte2 <= 0x8F) {
                    // Строчные -> заглавные
                    data[i] = 0xD0;
                    data[i + 1] = byte2 - 0x10;
                }
                // Буква Ё (U+0401)
                else if (byte1 == 0xD0 && byte2 == 0x81) {
                    // Ё -> ё
                    data[i] = 0xD1;
                    data[i + 1] = 0x91;
                }
                // Буква ё (U+0451)
                else if (byte1 == 0xD1 && byte2 == 0x91) {
                    // ё -> Ё
                    data[i] = 0xD0;
                    data[i + 1] = 0x81;
                }
            }
            i += 2;
        }
        else {
            // Пропускаем другие многобайтовые символы
            i++;
        }
    }
}

/* Callback при получении данных */
err_t data_received_callback(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err) {
    conn_data_t *conn_data = (conn_data_t *)arg;

    if (!p) {
        /* Соединение закрыто */
        tcp_close(tpcb);
        tcp_recv(tpcb, NULL);
        if (conn_data) {
            mem_free(conn_data);
        }
        connection_count--;
        xil_printf("[СЕТЬ] Соединение закрыто. Активных: %d\r\n", connection_count);
        return ERR_OK;
    }

    /* Копируем данные */
    conn_data->data_length = p->len;
    if (conn_data->data_length > sizeof(conn_data->buffer) - 1) {
        conn_data->data_length = sizeof(conn_data->buffer) - 1;
    }

    memcpy(conn_data->buffer, p->payload, conn_data->data_length);
    conn_data->buffer[conn_data->data_length] = '\0';

    /* Сохраняем для консоли */
    data_received_flag = 1;
    strncpy(last_received_data, conn_data->buffer, sizeof(last_received_data)-1);
    last_received_data[sizeof(last_received_data)-1] = '\0';

    xil_printf("[СЕТЬ] Получено %d байт: %s\r\n", conn_data->data_length, conn_data->buffer);

    /* Обрабатываем данные - используем улучшенную версию для русского */
    process_received_data_improved(conn_data->buffer, conn_data->data_length);

    /* Создаем финальную строку с префиксом */
    char final_buffer[1024];
    int final_length = snprintf(final_buffer, sizeof(final_buffer), "PROCESSED: %s", conn_data->buffer);

    if (final_length >= sizeof(final_buffer)) {
        final_length = sizeof(final_buffer) - 1;
        final_buffer[final_length] = '\0';
    }

    /* Проверяем место в буфере отправки */
    if (tcp_sndbuf(tpcb) < final_length) {
        xil_printf("[СЕТЬ] Мало места в буфере отправки: %d < %d\r\n", tcp_sndbuf(tpcb), final_length);
        pbuf_free(p);
        return ERR_MEM;
    }

    /* Отправляем обработанные данные */
    err_t write_err = tcp_write(tpcb, final_buffer, final_length, TCP_WRITE_FLAG_COPY);
    if (write_err != ERR_OK) {
        xil_printf("[СЕТЬ] Ошибка отправки: %d\r\n", write_err);
        pbuf_free(p);
        return write_err;
    }

    /* Подтверждаем получение */
    tcp_recved(tpcb, p->len);
    pbuf_free(p);

    xil_printf("[СЕТЬ] Отправлено %d байт: %s\r\n", final_length, final_buffer);

    return ERR_OK;
}

/* Callback при новом соединении */
err_t connection_accepted_callback(void *arg, struct tcp_pcb *newpcb, err_t err) {
    conn_data_t *conn_data;

    if (err != ERR_OK || newpcb == NULL) {
        xil_printf("[СЕТЬ] Ошибка принятия соединения: %d\r\n", err);
        return ERR_VAL;
    }

    /* Выделяем память */
    conn_data = (conn_data_t *)mem_malloc(sizeof(conn_data_t));
    if (conn_data == NULL) {
        xil_printf("[СЕТЬ] Ошибка выделения памяти\r\n");
        return ERR_MEM;
    }

    memset(conn_data, 0, sizeof(conn_data_t));
    conn_data->pcb = newpcb;
    conn_data->data_length = 0;

    tcp_recv(newpcb, data_received_callback);
    tcp_arg(newpcb, conn_data);

    connection_count++;
    xil_printf("[СЕТЬ] Новое соединение. Активных: %d\r\n", connection_count);

    return ERR_OK;
}

/* Функция для консоли */
void get_network_stats(int *connections, int *data_flag, char *last_data) {
    *connections = connection_count;
    *data_flag = data_received_flag;
    if (data_received_flag) {
        strncpy(last_data, last_received_data, sizeof(last_received_data)-1);
        last_data[sizeof(last_received_data)-1] = '\0';
        data_received_flag = 0;
    } else {
        last_data[0] = '\0';
    }
}

/* Запуск TCP-сервера */
void start_custom_application(void) {
    struct tcp_pcb *pcb;
    err_t err;

    /* Создаем PCB */
    pcb = tcp_new();
    if (!pcb) {
        xil_printf("[СЕТЬ] Ошибка создания PCB\r\n");
        return;
    }

    /* Биндим на порт 12345 */
    err = tcp_bind(pcb, IP_ADDR_ANY, 12345);
    if (err != ERR_OK) {
        xil_printf("[СЕТЬ] Ошибка bind на порт 12345: %d\r\n", err);
        tcp_close(pcb);
        return;
    }

    /* Слушаем соединения */
    pcb = tcp_listen(pcb);
    if (!pcb) {
        xil_printf("[СЕТЬ] Ошибка listen\r\n");
        return;
    }

    /* Устанавливаем callback для принятия соединений */
    tcp_accept(pcb, connection_accepted_callback);

    xil_printf("[СЕТЬ] TCP-сервер запущен на порту 12345\r\n");
    xil_printf("[СЕТЬ] Поддержка русского языка: ДА\r\n");
    xil_printf("[СЕТЬ] Готов к приему подключений\r\n");
}
