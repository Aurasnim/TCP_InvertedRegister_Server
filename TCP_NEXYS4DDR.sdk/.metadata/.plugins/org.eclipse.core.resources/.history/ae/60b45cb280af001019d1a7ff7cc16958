#include <stdio.h>
#include <string.h>
#include "lwip/err.h"
#include "lwip/tcp.h"
#include "xil_printf.h"

/* Структура для хранения данных соединения */
typedef struct {
    struct tcp_pcb *pcb;
    char buffer[1024];
    int data_length;
} custom_conn_data_t;

/* Глобальные переменные для интеграции с консолью */
int data_received_flag = 0;
char last_received_data[256];
int connection_count = 0;

/* Функция обработки данных - ВАША ОСНОВНАЯ ЛОГИКА */
void process_received_data(char *data, int length) {
    /* ПРИМЕР: Инвертирование регистра + добавление префикса */
    for (int i = 0; i < length; i++) {
        if (data[i] >= 'a' && data[i] <= 'z') {
            data[i] = data[i] - 'a' + 'A';
        } else if (data[i] >= 'A' && data[i] <= 'Z') {
            data[i] = data[i] - 'A' + 'a';
        }
    }

    /* Добавляем префикс */
    char temp[1024];
    snprintf(temp, sizeof(temp), "PROCESSED: %s", data);
    strncpy(data, temp, length + 20);
}

/* Функция отправки обработанных данных */
err_t send_processed_data(struct tcp_pcb *pcb, char *data, int length) {
    err_t err;

    if (tcp_sndbuf(pcb) > length) {
        err = tcp_write(pcb, data, length, 1);
        if (err != ERR_OK) {
            xil_printf("Ошибка отправки данных: %d\n\r", err);
            return err;
        }
    } else {
        xil_printf("Недостаточно места в буфере отправки\n\r");
        return ERR_MEM;
    }

    return ERR_OK;
}

/* Callback при получении данных */
err_t data_received_callback(void *arg, struct tcp_pcb *tpcb,
                            struct pbuf *p, err_t err) {
    custom_conn_data_t *conn_data = (custom_conn_data_t *)arg;

    if (!p) {
        /* Соединение закрыто */
        tcp_close(tpcb);
        tcp_recv(tpcb, NULL);
        if (conn_data) {
            mem_free(conn_data);
        }
        connection_count--;
        xil_printf("[СЕТЬ] Соединение закрыто. Активных: %d\r\n", connection_count);
        return ERR_OK;
    }

    /* Копируем данные из pbuf в наш буфер */
    int data_len = p->len;
    if (data_len > sizeof(conn_data->buffer) - 1) {
        data_len = sizeof(conn_data->buffer) - 1;
    }

    memcpy(conn_data->buffer, p->payload, data_len);
    conn_data->buffer[data_len] = '\0';
    conn_data->data_length = data_len;

    /* Сохраняем для отображения в консоли */
    data_received_flag = 1;
    strncpy(last_received_data, conn_data->buffer, sizeof(last_received_data)-1);

    xil_printf("[СЕТЬ] Получены данные: %s\r\n", conn_data->buffer);

    /* ОБРАБАТЫВАЕМ ДАННЫЕ */
    process_received_data(conn_data->buffer, conn_data->data_length);

    /* Отправляем обработанные данные обратно */
    send_processed_data(tpcb, conn_data->buffer, strlen(conn_data->buffer));

    /* Подтверждаем получение */
    tcp_recved(tpcb, p->len);

    /* Освобождаем pbuf */
    pbuf_free(p);

    return ERR_OK;
}

/* Callback при новом соединении */
err_t connection_accepted_callback(void *arg, struct tcp_pcb *newpcb, err_t err) {
    custom_conn_data_t *conn_data;

    if (err != ERR_OK || newpcb == NULL) {
        return ERR_VAL;
    }

    /* Выделяем память для данных соединения */
    conn_data = (custom_conn_data_t *)mem_malloc(sizeof(custom_conn_data_t));
    if (conn_data == NULL) {
        xil_printf("Ошибка выделения памяти для данных соединения\n\r");
        return ERR_MEM;
    }

    /* Инициализируем структуру */
    memset(conn_data, 0, sizeof(custom_conn_data_t));
    conn_data->pcb = newpcb;

    /* Устанавливаем callback для приема данных */
    tcp_recv(newpcb, data_received_callback);

    /* Сохраняем данные соединения */
    tcp_arg(newpcb, conn_data);

    connection_count++;
    xil_printf("[СЕТЬ] Новое соединение установлено. Активных: %d\r\n", connection_count);

    return ERR_OK;
}

/* Функция получения статистики для консоли */
void get_network_stats(int *connections, int *data_flag, char *last_data) {
    *connections = connection_count;
    *data_flag = data_received_flag;
    if (data_received_flag) {
        strncpy(last_data, last_received_data, 255);
        data_received_flag = 0;  // Сбрасываем флаг после чтения
    } else {
        last_data[0] = '\0';
    }
}

/* Функция запуска приложения */
void start_custom_application(void) {
    struct tcp_pcb *pcb;
    err_t err;
    unsigned port = 12345;  /* Ваш порт */

    /* Создаем TCP PCB */
    pcb = tcp_new_ip_type(IPADDR_TYPE_ANY);
    if (!pcb) {
        xil_printf("Ошибка создания PCB. Недостаточно памяти\n\r");
        return;
    }

    /* Биндим на порт */
    err = tcp_bind(pcb, IP_ANY_TYPE, port);
    if (err != ERR_OK) {
        xil_printf("Ошибка bind на порт %d: err = %d\n\r", port, err);
        mem_free(pcb);
        return;
    }

    /* Слушаем соединения */
    pcb = tcp_listen(pcb);
    if (!pcb) {
        xil_printf("Ошибка listen. Недостаточно памяти\n\r");
        return;
    }

    /* Устанавливаем callback для принятия соединений */
    tcp_accept(pcb, connection_accepted_callback);

    xil_printf("[СЕТЬ] TCP-сервер запущен на порту %d\r\n", port);
    xil_printf("[СЕТЬ] Ожидание подключений...\r\n");
}
